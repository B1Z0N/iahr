<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>iahr.utils API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>iahr.utils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from telethon import events

from dataclasses import dataclass
import re, json, inspect


class Delimiter:
    RE_ESCAPINGS = r&#39;.^$*+-?()[]{}\|&#39;

    def __init__(self, delim: str):
        self.re_sensitive = delim in self.RE_ESCAPINGS
        self.original = delim
        self.escaped = &#39;\\&#39; + delim

    def in_re(self):
        return self.escaped if self.re_sensitive else self.original

    def unescape(self, s):
        return self.escaped_replace(s, self.original)

    def escape(self, s):
        return self.unescaped_replace(s, self.escaped)

    def escaped_replace(self, string, to):
        return string.replace(self.escaped, to)

    def unescaped_re(self):
        return r&#39;(?&lt;!\\){}&#39;.format(self.in_re())

    def unescaped_replace(self, string, to):
        return re.sub(self.unescaped_re(), to, string)

    def __repr__(self):
        return f&#39;Delimtier({self.original})&#39;


class CommandDelimiter(Delimiter):
    def full_command(self, cmd):
        return self.original + cmd

    def is_command(self, s):
        return s.startswith(self.original)


class Delayed:
    def __init__(self):
        self.operation = None
        self.delayed = []

    def do(self, *args, **kwargs):
        if self.operation is None:
            self.delayed.append((args, kwargs))
        else:
            self.operation(*args, **kwargs)

    def undelay(self):
        if self.operation is None:
            return
        for el in self.delayed:
            args, kwargs = el
            self.operation(*args, **kwargs)
        self.delayed = []

    def init(self, operation):
        self.operation = operation
        self.undelay()

    def __repr__(self):
        return f&#39;Delayed(delayed={self.delayed})&#39;


class SingletonMeta(type):
    &#34;&#34;&#34;
    The Singleton class can be implemented in different ways in Python. Some
    possible methods include: base class, decorator, metaclass. We will use the
    metaclass because it is best suited for this purpose.
    &#34;&#34;&#34;

    _instance = None

    def __call__(self):
        if self._instance is None:
            self._instance = super().__call__()
        return self._instance


class ParseError(Exception):
    def __init__(self, s):
        super().__init__(IahrConfig.LOCAL[&#39;ParseError&#39;].format(s))


def errstr(s, ebegin, eend):
    &#34;&#34;&#34;
        errstr(&#39;.do r[err]&#39;, 4, 6)

        .do **r[**err]
              ^^
    &#34;&#34;&#34;
    before, err, after = s[:ebegin], s[ebegin:eend], s[eend:]
    res = f&#39;{before}`{err}`{after}&#39;
    return res


def parenthesize(ldel, rdel, cmd_del, raw_del):
    left, right = ldel.original, rdel.original
    cmdd, raw = cmd_del.original, raw_del.original

    def next_delim(s, start):
        space_i = s.find(&#39; &#39;, start)
        rmatch = re.search(rdel.unescaped_re(), s[start:])
        right_i = -1 if rmatch is None else rmatch.start() + start

        if space_i == -1:
            return right_i
        elif space_i &lt; right_i:
            return space_i
        else:
            return right_i

    def surround(s):
        return s if s.startswith(left) else left + s + right

    def is_left_raw(s, i):
        return s[i] == raw and i + 1 &lt; len(s) and s[i + 1] == left

    def is_right_raw(s, i):
        return s[i] == right and i + 1 &lt; len(s) and s[i + 1] == raw

    def is_unescaped(c):
        def _(s, i):
            return i &lt; len(s) and s[i] == c and i &gt; 0 and s[i - 1] != &#39;\\&#39;

        return _

    is_command, is_left, is_right = is_unescaped(cmdd), \
        is_unescaped(left), is_unescaped(right)

    def full_escape(s):
        return cmd_del.escape(rdel.escape(ldel.escape(s)))

    def do_raw(s, i):
        errstart = i
        start = i + 2
        while i &lt; len(s) and not is_right_raw(s, i):
            i += 1
        if i == len(s):
            msg = errstr(s, errstart, errstart + 2)
            raise ParseError(
                IahrConfig.LOCAL[&#39;Unbalanced raw&#39;]
                    .format(f&#39;&#34;{raw}{left} {right}{raw}&#34;:\n\n{msg}&#39;)
            )
        return surround(full_escape(s[start:i])), i + 2

    def do(s, i):
        errstart = i
        open_cnt, res = 0, &#39;&#39;
        cmd_arg = False
        while not is_right(s, i):
            if len(s) == i:
                msg = errstr(s, errstart - 1, errstart)
                raise ParseError(
                    IahrConfig.LOCAL[&#39;Unbalanced&#39;]
                        .format(f&#39;{left} {right}&#34;\n\n{msg}&#39;)
                )

            if is_left_raw(s, i):
                subres, i = do_raw(s, i)
                res += subres
            elif is_left(s, i):
                subres, i = do(s, i + 1)
                res += surround(subres)
                i += 1
            elif is_command(s, i):
                start, i = i, next_delim(s, i)
                res += left + s[start:i]
                open_cnt += 1
                cmd_arg = True
            elif s[i] == &#39; &#39; or not cmd_arg:
                res += s[i]
                i += 1
            else:
                start, i = i, next_delim(s, i)
                res += left + s[start:i] + right

        return res + right * open_cnt, i

    return lambda s: do(surround(s), 1)[0]


class Tokenizer:
    &#34;&#34;&#34;
        Class to tokenize to command text
    &#34;&#34;&#34;

    # match
    # 1) spaces
    # 2) any characters (including `\)` and `\(`) without `(` and `)`
    # 3) `(` and `)`
    TOKS = re.compile(r&#39; +|((\\\()|(\\\))|([^\(\)]))+|[()]&#39;)

    def __init__(self, s):
        self.s = s

    def tokenize(self):
        &#34;&#34;&#34;
            Tokenize a string.
            Tokens yielded are of the form (type, string)
            Possible values for &#39;type&#39; are &#39;(&#39;, &#39;)&#39; and &#39;WORD&#39;
        &#34;&#34;&#34;
        s = self.s
        for match in self.TOKS.finditer(s):
            s = match.group(0)
            if s[0] == &#39; &#39;:
                continue
            if s[0] in &#39;()&#39;:
                yield s, s
            else:
                yield &#39;WORD&#39;, self.unescape(s[1:-1])

    @classmethod
    def parse_inner(cls, toks):
        &#34;&#34;&#34;
            Parse once we&#39;re inside an opening bracket.
        &#34;&#34;&#34;
        ty, name = next(toks)
        children = []
        if ty != &#39;WORD&#39;:
            raise ParseError(IahrConfig.LOCAL[&#39;Brackets should start&#39;])

        while True:
            ty, s = next(toks)
            if ty == &#39;(&#39;:
                children.append(cls.parse_inner(toks))
            elif ty == &#39;)&#39;:
                return name, children

    @classmethod
    def parse_root(cls, toks):
        &#34;&#34;&#34;
            Parse this grammar:
            ROOT ::= &#39;(&#39; INNER
            INNER ::= WORD ROOT* &#39;)&#39;
            WORD ::= [A-Za-z]+
        &#34;&#34;&#34;
        ty, _ = next(toks)
        if ty != &#39;(&#39;:
            raise ParseError(IahrConfig.LOCAL[&#39;Surround tokens&#39;])
        return cls.parse_inner(toks)

    def perform(self):
        &#34;&#34;&#34;
            Commodity function that glues it alltogether 
        &#34;&#34;&#34;
        toks = self.tokenize()
        return self.parse_root(toks)

    @classmethod
    def from_str(cls, s, leftdel: Delimiter, rightdel: Delimiter):
        &#34;&#34;&#34;
            Recursive lists from string
        &#34;&#34;&#34;
        s = cls.escape(s)
        # surround it with double delimiters for correct space handling
        s = leftdel.unescaped_replace(s, &#34;(&#39;&#34;)
        s = rightdel.unescaped_replace(s, &#34;&#39;)&#34;)
        obj = cls(s)
        return obj.perform()

    @staticmethod
    def escape(s):
        return s.replace(&#39;(&#39;, r&#39;\(&#39;).replace(&#39;)&#39;, r&#39;\)&#39;)

    @staticmethod
    def unescape(s):
        return s.replace(r&#39;\(&#39;, &#39;(&#39;).replace(r&#39;\)&#39;, &#39;)&#39;)

    @classmethod
    def show_children(cls, tree):
        &#34;&#34;&#34;
            Pretty print commands and it&#39;s args
        &#34;&#34;&#34;
        name, children = tree
        if not children: return
        print(&#39;{} -&gt; {}&#39;.format(name,
                                &#39; &#39;.join(child[0] for child in children)))
        for child in children:
            cls.show_children(child)


# import here, due to the circular import
from .config import IahrConfig


class AccessList:
    &#34;&#34;&#34;
        Users and groups access manager
    &#34;&#34;&#34;
    # Current user is enabled by default and can&#39;t be disabled

    @classmethod
    def is_special(cls, ent):
        return ent in (IahrConfig.OTHERS, IahrConfig.ME)

    def __init__(self, allow_others=False):

        self.whitelist = set()
        self.blacklist = set()
        self.allow_others = allow_others

    def allow(self, entity: str):
        if entity == IahrConfig.ME:
            return

        if entity == IahrConfig.OTHERS:
            self.whitelist = set()
            self.blacklist = set()
            self.allow_others = True
        elif self.allow_others is False:
            self.whitelist.add(entity)
        elif entity in self.blacklist:
            self.blacklist.remove(entity)

    def ban(self, entity: str):
        if entity == IahrConfig.ME:
            return

        if entity == IahrConfig.OTHERS:
            self.whitelist = self.blacklist = set()
            self.allow_others = False
        elif self.allow_others is True:
            self.blacklist.add(entity)
        elif entity in self.whitelist:
            self.whitelist.remove(entity)

    def is_allowed(self, entity: str):
        me = entity == IahrConfig.ME
        return me or (self.allow_others and entity not in self.blacklist)\
                or (not self.allow_others and entity in self.whitelist)

    def __repr__(self):
        return &#39;AccessList(whitelist: {}, blacklist: {}, allow_others: {})&#39;\
                .format(self.whitelist, self.blacklist, self.allow_others)

    @classmethod
    async def check_me(cls, client):
        me = await client.get_me()
        myid = me.id

        def check(eid):
            return IahrConfig.ME if eid == myid else eid

        return check

    class ALEncoder(json.JSONEncoder):
        def default(self, obj):
            if isinstance(obj, AccessList):
                return {
                    &#39;AccessList&#39;: {
                        &#39;others&#39;: obj.allow_others,
                        &#39;whitelist&#39;: list(obj.whitelist),
                        &#39;blacklist&#39;: list(obj.blacklist),
                    }
                }

            return json.JSONEncoder.default(self, obj)

    class ALDecoder(json.JSONDecoder):
        def __init__(self, *args, **kwargs):
            json.JSONDecoder.__init__(self,
                                      object_hook=self.object_hook,
                                      *args,
                                      **kwargs)

        def object_hook(self, dct):
            if &#39;AccessList&#39; in dct:
                alst, dct = AccessList(), dct[&#39;AccessList&#39;]
                alst.allow_others = dct[&#39;others&#39;]
                alst.whitelist = set(dct[&#39;whitelist&#39;])
                alst.blacklist = set(dct[&#39;blacklist&#39;])
                return alst
            return dct


@dataclass
class ActionData:
    &#34;&#34;&#34;
        Contains event and shortcut info about it&#39;s author
    &#34;&#34;&#34;
    event: events.common.EventCommon
    uid: int
    chatid: int

    @classmethod
    async def from_event(cls, event: events.NewMessage):
        me = await AccessList.check_me(event.client)
        uid = event.message.from_id
        c = await event.message.get_chat()
        return cls(event, me(uid), me(c.id))


def argstr(fun, remove_event=True):
    spec = inspect.getfullargspec(fun)
    args = spec.args
    if remove_event:
        args = spec.args[1:]

    if spec.defaults is not None:
        division = len(spec.defaults)
        args, kwargs = args[:-division], args[-division:]
        kwargs = zip(kwargs, spec.defaults)
    else:
        kwargs = []

    res = &#39; &#39;.join(args) + &#39; &#39;
    res += &#39; &#39;.join(&#39;{}={}&#39;.format(arg, val) for arg, val in kwargs) + &#39; &#39;

    if spec.varargs is not None:
        res += &#39; *&#39; + spec.varargs + &#39; &#39;
    if spec.kwonlydefaults is not None:
        res += &#39; &#39;.join(arg + &#39;=&#39; + val
                        for arg, val in spec.kwonlydefaults.items())
    if spec.varkw is not None:
        res += &#39; **&#39; + spec.varkw

    return res</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="iahr.utils.argstr"><code class="name flex">
<span>def <span class="ident">argstr</span></span>(<span>fun, remove_event=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def argstr(fun, remove_event=True):
    spec = inspect.getfullargspec(fun)
    args = spec.args
    if remove_event:
        args = spec.args[1:]

    if spec.defaults is not None:
        division = len(spec.defaults)
        args, kwargs = args[:-division], args[-division:]
        kwargs = zip(kwargs, spec.defaults)
    else:
        kwargs = []

    res = &#39; &#39;.join(args) + &#39; &#39;
    res += &#39; &#39;.join(&#39;{}={}&#39;.format(arg, val) for arg, val in kwargs) + &#39; &#39;

    if spec.varargs is not None:
        res += &#39; *&#39; + spec.varargs + &#39; &#39;
    if spec.kwonlydefaults is not None:
        res += &#39; &#39;.join(arg + &#39;=&#39; + val
                        for arg, val in spec.kwonlydefaults.items())
    if spec.varkw is not None:
        res += &#39; **&#39; + spec.varkw

    return res</code></pre>
</details>
</dd>
<dt id="iahr.utils.errstr"><code class="name flex">
<span>def <span class="ident">errstr</span></span>(<span>s, ebegin, eend)</span>
</code></dt>
<dd>
<div class="desc"><p>errstr('.do r[err]', 4, 6)</p>
<p>.do <strong>r[</strong>err]
^^</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def errstr(s, ebegin, eend):
    &#34;&#34;&#34;
        errstr(&#39;.do r[err]&#39;, 4, 6)

        .do **r[**err]
              ^^
    &#34;&#34;&#34;
    before, err, after = s[:ebegin], s[ebegin:eend], s[eend:]
    res = f&#39;{before}`{err}`{after}&#39;
    return res</code></pre>
</details>
</dd>
<dt id="iahr.utils.parenthesize"><code class="name flex">
<span>def <span class="ident">parenthesize</span></span>(<span>ldel, rdel, cmd_del, raw_del)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parenthesize(ldel, rdel, cmd_del, raw_del):
    left, right = ldel.original, rdel.original
    cmdd, raw = cmd_del.original, raw_del.original

    def next_delim(s, start):
        space_i = s.find(&#39; &#39;, start)
        rmatch = re.search(rdel.unescaped_re(), s[start:])
        right_i = -1 if rmatch is None else rmatch.start() + start

        if space_i == -1:
            return right_i
        elif space_i &lt; right_i:
            return space_i
        else:
            return right_i

    def surround(s):
        return s if s.startswith(left) else left + s + right

    def is_left_raw(s, i):
        return s[i] == raw and i + 1 &lt; len(s) and s[i + 1] == left

    def is_right_raw(s, i):
        return s[i] == right and i + 1 &lt; len(s) and s[i + 1] == raw

    def is_unescaped(c):
        def _(s, i):
            return i &lt; len(s) and s[i] == c and i &gt; 0 and s[i - 1] != &#39;\\&#39;

        return _

    is_command, is_left, is_right = is_unescaped(cmdd), \
        is_unescaped(left), is_unescaped(right)

    def full_escape(s):
        return cmd_del.escape(rdel.escape(ldel.escape(s)))

    def do_raw(s, i):
        errstart = i
        start = i + 2
        while i &lt; len(s) and not is_right_raw(s, i):
            i += 1
        if i == len(s):
            msg = errstr(s, errstart, errstart + 2)
            raise ParseError(
                IahrConfig.LOCAL[&#39;Unbalanced raw&#39;]
                    .format(f&#39;&#34;{raw}{left} {right}{raw}&#34;:\n\n{msg}&#39;)
            )
        return surround(full_escape(s[start:i])), i + 2

    def do(s, i):
        errstart = i
        open_cnt, res = 0, &#39;&#39;
        cmd_arg = False
        while not is_right(s, i):
            if len(s) == i:
                msg = errstr(s, errstart - 1, errstart)
                raise ParseError(
                    IahrConfig.LOCAL[&#39;Unbalanced&#39;]
                        .format(f&#39;{left} {right}&#34;\n\n{msg}&#39;)
                )

            if is_left_raw(s, i):
                subres, i = do_raw(s, i)
                res += subres
            elif is_left(s, i):
                subres, i = do(s, i + 1)
                res += surround(subres)
                i += 1
            elif is_command(s, i):
                start, i = i, next_delim(s, i)
                res += left + s[start:i]
                open_cnt += 1
                cmd_arg = True
            elif s[i] == &#39; &#39; or not cmd_arg:
                res += s[i]
                i += 1
            else:
                start, i = i, next_delim(s, i)
                res += left + s[start:i] + right

        return res + right * open_cnt, i

    return lambda s: do(surround(s), 1)[0]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="iahr.utils.AccessList"><code class="flex name class">
<span>class <span class="ident">AccessList</span></span>
<span>(</span><span>allow_others=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Users and groups access manager</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AccessList:
    &#34;&#34;&#34;
        Users and groups access manager
    &#34;&#34;&#34;
    # Current user is enabled by default and can&#39;t be disabled

    @classmethod
    def is_special(cls, ent):
        return ent in (IahrConfig.OTHERS, IahrConfig.ME)

    def __init__(self, allow_others=False):

        self.whitelist = set()
        self.blacklist = set()
        self.allow_others = allow_others

    def allow(self, entity: str):
        if entity == IahrConfig.ME:
            return

        if entity == IahrConfig.OTHERS:
            self.whitelist = set()
            self.blacklist = set()
            self.allow_others = True
        elif self.allow_others is False:
            self.whitelist.add(entity)
        elif entity in self.blacklist:
            self.blacklist.remove(entity)

    def ban(self, entity: str):
        if entity == IahrConfig.ME:
            return

        if entity == IahrConfig.OTHERS:
            self.whitelist = self.blacklist = set()
            self.allow_others = False
        elif self.allow_others is True:
            self.blacklist.add(entity)
        elif entity in self.whitelist:
            self.whitelist.remove(entity)

    def is_allowed(self, entity: str):
        me = entity == IahrConfig.ME
        return me or (self.allow_others and entity not in self.blacklist)\
                or (not self.allow_others and entity in self.whitelist)

    def __repr__(self):
        return &#39;AccessList(whitelist: {}, blacklist: {}, allow_others: {})&#39;\
                .format(self.whitelist, self.blacklist, self.allow_others)

    @classmethod
    async def check_me(cls, client):
        me = await client.get_me()
        myid = me.id

        def check(eid):
            return IahrConfig.ME if eid == myid else eid

        return check

    class ALEncoder(json.JSONEncoder):
        def default(self, obj):
            if isinstance(obj, AccessList):
                return {
                    &#39;AccessList&#39;: {
                        &#39;others&#39;: obj.allow_others,
                        &#39;whitelist&#39;: list(obj.whitelist),
                        &#39;blacklist&#39;: list(obj.blacklist),
                    }
                }

            return json.JSONEncoder.default(self, obj)

    class ALDecoder(json.JSONDecoder):
        def __init__(self, *args, **kwargs):
            json.JSONDecoder.__init__(self,
                                      object_hook=self.object_hook,
                                      *args,
                                      **kwargs)

        def object_hook(self, dct):
            if &#39;AccessList&#39; in dct:
                alst, dct = AccessList(), dct[&#39;AccessList&#39;]
                alst.allow_others = dct[&#39;others&#39;]
                alst.whitelist = set(dct[&#39;whitelist&#39;])
                alst.blacklist = set(dct[&#39;blacklist&#39;])
                return alst
            return dct</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="iahr.utils.AccessList.ALDecoder"><code class="name">var <span class="ident">ALDecoder</span></code></dt>
<dd>
<div class="desc"><p>Simple JSON <a href="http://json.org">http://json.org</a> decoder</p>
<p>Performs the following translations in decoding by default:</p>
<p>+---------------+-------------------+
| JSON
| Python
|
+===============+===================+
| object
| dict
|
+---------------+-------------------+
| array
| list
|
+---------------+-------------------+
| string
| str
|
+---------------+-------------------+
| number (int)
| int
|
+---------------+-------------------+
| number (real) | float
|
+---------------+-------------------+
| true
| True
|
+---------------+-------------------+
| false
| False
|
+---------------+-------------------+
| null
| None
|
+---------------+-------------------+</p>
<p>It also understands <code>NaN</code>, <code>Infinity</code>, and <code>-Infinity</code> as
their corresponding <code>float</code> values, which is outside the JSON spec.</p></div>
</dd>
<dt id="iahr.utils.AccessList.ALEncoder"><code class="name">var <span class="ident">ALEncoder</span></code></dt>
<dd>
<div class="desc"><p>Extensible JSON <a href="http://json.org">http://json.org</a> encoder for Python data structures.</p>
<p>Supports the following objects and types by default:</p>
<p>+-------------------+---------------+
| Python
| JSON
|
+===================+===============+
| dict
| object
|
+-------------------+---------------+
| list, tuple
| array
|
+-------------------+---------------+
| str
| string
|
+-------------------+---------------+
| int, float
| number
|
+-------------------+---------------+
| True
| true
|
+-------------------+---------------+
| False
| false
|
+-------------------+---------------+
| None
| null
|
+-------------------+---------------+</p>
<p>To extend this to recognize other objects, subclass and implement a
<code>.default()</code> method with another method that returns a serializable
object for <code>o</code> if possible, otherwise it should call the superclass
implementation (to raise <code>TypeError</code>).</p></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="iahr.utils.AccessList.check_me"><code class="name flex">
<span>async def <span class="ident">check_me</span></span>(<span>client)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def check_me(cls, client):
    me = await client.get_me()
    myid = me.id

    def check(eid):
        return IahrConfig.ME if eid == myid else eid

    return check</code></pre>
</details>
</dd>
<dt id="iahr.utils.AccessList.is_special"><code class="name flex">
<span>def <span class="ident">is_special</span></span>(<span>ent)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_special(cls, ent):
    return ent in (IahrConfig.OTHERS, IahrConfig.ME)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="iahr.utils.AccessList.allow"><code class="name flex">
<span>def <span class="ident">allow</span></span>(<span>self, entity: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def allow(self, entity: str):
    if entity == IahrConfig.ME:
        return

    if entity == IahrConfig.OTHERS:
        self.whitelist = set()
        self.blacklist = set()
        self.allow_others = True
    elif self.allow_others is False:
        self.whitelist.add(entity)
    elif entity in self.blacklist:
        self.blacklist.remove(entity)</code></pre>
</details>
</dd>
<dt id="iahr.utils.AccessList.ban"><code class="name flex">
<span>def <span class="ident">ban</span></span>(<span>self, entity: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ban(self, entity: str):
    if entity == IahrConfig.ME:
        return

    if entity == IahrConfig.OTHERS:
        self.whitelist = self.blacklist = set()
        self.allow_others = False
    elif self.allow_others is True:
        self.blacklist.add(entity)
    elif entity in self.whitelist:
        self.whitelist.remove(entity)</code></pre>
</details>
</dd>
<dt id="iahr.utils.AccessList.is_allowed"><code class="name flex">
<span>def <span class="ident">is_allowed</span></span>(<span>self, entity: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_allowed(self, entity: str):
    me = entity == IahrConfig.ME
    return me or (self.allow_others and entity not in self.blacklist)\
            or (not self.allow_others and entity in self.whitelist)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="iahr.utils.ActionData"><code class="flex name class">
<span>class <span class="ident">ActionData</span></span>
<span>(</span><span>event: telethon.events.common.EventCommon, uid: int, chatid: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains event and shortcut info about it's author</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ActionData:
    &#34;&#34;&#34;
        Contains event and shortcut info about it&#39;s author
    &#34;&#34;&#34;
    event: events.common.EventCommon
    uid: int
    chatid: int

    @classmethod
    async def from_event(cls, event: events.NewMessage):
        me = await AccessList.check_me(event.client)
        uid = event.message.from_id
        c = await event.message.get_chat()
        return cls(event, me(uid), me(c.id))</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="iahr.utils.ActionData.from_event"><code class="name flex">
<span>async def <span class="ident">from_event</span></span>(<span>event: telethon.events.newmessage.NewMessage)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
async def from_event(cls, event: events.NewMessage):
    me = await AccessList.check_me(event.client)
    uid = event.message.from_id
    c = await event.message.get_chat()
    return cls(event, me(uid), me(c.id))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="iahr.utils.CommandDelimiter"><code class="flex name class">
<span>class <span class="ident">CommandDelimiter</span></span>
<span>(</span><span>delim: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CommandDelimiter(Delimiter):
    def full_command(self, cmd):
        return self.original + cmd

    def is_command(self, s):
        return s.startswith(self.original)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="iahr.utils.Delimiter" href="#iahr.utils.Delimiter">Delimiter</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="iahr.utils.CommandDelimiter.full_command"><code class="name flex">
<span>def <span class="ident">full_command</span></span>(<span>self, cmd)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def full_command(self, cmd):
    return self.original + cmd</code></pre>
</details>
</dd>
<dt id="iahr.utils.CommandDelimiter.is_command"><code class="name flex">
<span>def <span class="ident">is_command</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_command(self, s):
    return s.startswith(self.original)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="iahr.utils.Delayed"><code class="flex name class">
<span>class <span class="ident">Delayed</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Delayed:
    def __init__(self):
        self.operation = None
        self.delayed = []

    def do(self, *args, **kwargs):
        if self.operation is None:
            self.delayed.append((args, kwargs))
        else:
            self.operation(*args, **kwargs)

    def undelay(self):
        if self.operation is None:
            return
        for el in self.delayed:
            args, kwargs = el
            self.operation(*args, **kwargs)
        self.delayed = []

    def init(self, operation):
        self.operation = operation
        self.undelay()

    def __repr__(self):
        return f&#39;Delayed(delayed={self.delayed})&#39;</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="iahr.utils.Delayed.do"><code class="name flex">
<span>def <span class="ident">do</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def do(self, *args, **kwargs):
    if self.operation is None:
        self.delayed.append((args, kwargs))
    else:
        self.operation(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="iahr.utils.Delayed.init"><code class="name flex">
<span>def <span class="ident">init</span></span>(<span>self, operation)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init(self, operation):
    self.operation = operation
    self.undelay()</code></pre>
</details>
</dd>
<dt id="iahr.utils.Delayed.undelay"><code class="name flex">
<span>def <span class="ident">undelay</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def undelay(self):
    if self.operation is None:
        return
    for el in self.delayed:
        args, kwargs = el
        self.operation(*args, **kwargs)
    self.delayed = []</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="iahr.utils.Delimiter"><code class="flex name class">
<span>class <span class="ident">Delimiter</span></span>
<span>(</span><span>delim: str)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Delimiter:
    RE_ESCAPINGS = r&#39;.^$*+-?()[]{}\|&#39;

    def __init__(self, delim: str):
        self.re_sensitive = delim in self.RE_ESCAPINGS
        self.original = delim
        self.escaped = &#39;\\&#39; + delim

    def in_re(self):
        return self.escaped if self.re_sensitive else self.original

    def unescape(self, s):
        return self.escaped_replace(s, self.original)

    def escape(self, s):
        return self.unescaped_replace(s, self.escaped)

    def escaped_replace(self, string, to):
        return string.replace(self.escaped, to)

    def unescaped_re(self):
        return r&#39;(?&lt;!\\){}&#39;.format(self.in_re())

    def unescaped_replace(self, string, to):
        return re.sub(self.unescaped_re(), to, string)

    def __repr__(self):
        return f&#39;Delimtier({self.original})&#39;</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="iahr.utils.CommandDelimiter" href="#iahr.utils.CommandDelimiter">CommandDelimiter</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="iahr.utils.Delimiter.RE_ESCAPINGS"><code class="name">var <span class="ident">RE_ESCAPINGS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="iahr.utils.Delimiter.escape"><code class="name flex">
<span>def <span class="ident">escape</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def escape(self, s):
    return self.unescaped_replace(s, self.escaped)</code></pre>
</details>
</dd>
<dt id="iahr.utils.Delimiter.escaped_replace"><code class="name flex">
<span>def <span class="ident">escaped_replace</span></span>(<span>self, string, to)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def escaped_replace(self, string, to):
    return string.replace(self.escaped, to)</code></pre>
</details>
</dd>
<dt id="iahr.utils.Delimiter.in_re"><code class="name flex">
<span>def <span class="ident">in_re</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def in_re(self):
    return self.escaped if self.re_sensitive else self.original</code></pre>
</details>
</dd>
<dt id="iahr.utils.Delimiter.unescape"><code class="name flex">
<span>def <span class="ident">unescape</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unescape(self, s):
    return self.escaped_replace(s, self.original)</code></pre>
</details>
</dd>
<dt id="iahr.utils.Delimiter.unescaped_re"><code class="name flex">
<span>def <span class="ident">unescaped_re</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unescaped_re(self):
    return r&#39;(?&lt;!\\){}&#39;.format(self.in_re())</code></pre>
</details>
</dd>
<dt id="iahr.utils.Delimiter.unescaped_replace"><code class="name flex">
<span>def <span class="ident">unescaped_replace</span></span>(<span>self, string, to)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unescaped_replace(self, string, to):
    return re.sub(self.unescaped_re(), to, string)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="iahr.utils.ParseError"><code class="flex name class">
<span>class <span class="ident">ParseError</span></span>
<span>(</span><span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ParseError(Exception):
    def __init__(self, s):
        super().__init__(IahrConfig.LOCAL[&#39;ParseError&#39;].format(s))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="iahr.utils.SingletonMeta"><code class="flex name class">
<span>class <span class="ident">SingletonMeta</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>The Singleton class can be implemented in different ways in Python. Some
possible methods include: base class, decorator, metaclass. We will use the
metaclass because it is best suited for this purpose.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SingletonMeta(type):
    &#34;&#34;&#34;
    The Singleton class can be implemented in different ways in Python. Some
    possible methods include: base class, decorator, metaclass. We will use the
    metaclass because it is best suited for this purpose.
    &#34;&#34;&#34;

    _instance = None

    def __call__(self):
        if self._instance is None:
            self._instance = super().__call__()
        return self._instance</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.type</li>
</ul>
</dd>
<dt id="iahr.utils.Tokenizer"><code class="flex name class">
<span>class <span class="ident">Tokenizer</span></span>
<span>(</span><span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to tokenize to command text</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Tokenizer:
    &#34;&#34;&#34;
        Class to tokenize to command text
    &#34;&#34;&#34;

    # match
    # 1) spaces
    # 2) any characters (including `\)` and `\(`) without `(` and `)`
    # 3) `(` and `)`
    TOKS = re.compile(r&#39; +|((\\\()|(\\\))|([^\(\)]))+|[()]&#39;)

    def __init__(self, s):
        self.s = s

    def tokenize(self):
        &#34;&#34;&#34;
            Tokenize a string.
            Tokens yielded are of the form (type, string)
            Possible values for &#39;type&#39; are &#39;(&#39;, &#39;)&#39; and &#39;WORD&#39;
        &#34;&#34;&#34;
        s = self.s
        for match in self.TOKS.finditer(s):
            s = match.group(0)
            if s[0] == &#39; &#39;:
                continue
            if s[0] in &#39;()&#39;:
                yield s, s
            else:
                yield &#39;WORD&#39;, self.unescape(s[1:-1])

    @classmethod
    def parse_inner(cls, toks):
        &#34;&#34;&#34;
            Parse once we&#39;re inside an opening bracket.
        &#34;&#34;&#34;
        ty, name = next(toks)
        children = []
        if ty != &#39;WORD&#39;:
            raise ParseError(IahrConfig.LOCAL[&#39;Brackets should start&#39;])

        while True:
            ty, s = next(toks)
            if ty == &#39;(&#39;:
                children.append(cls.parse_inner(toks))
            elif ty == &#39;)&#39;:
                return name, children

    @classmethod
    def parse_root(cls, toks):
        &#34;&#34;&#34;
            Parse this grammar:
            ROOT ::= &#39;(&#39; INNER
            INNER ::= WORD ROOT* &#39;)&#39;
            WORD ::= [A-Za-z]+
        &#34;&#34;&#34;
        ty, _ = next(toks)
        if ty != &#39;(&#39;:
            raise ParseError(IahrConfig.LOCAL[&#39;Surround tokens&#39;])
        return cls.parse_inner(toks)

    def perform(self):
        &#34;&#34;&#34;
            Commodity function that glues it alltogether 
        &#34;&#34;&#34;
        toks = self.tokenize()
        return self.parse_root(toks)

    @classmethod
    def from_str(cls, s, leftdel: Delimiter, rightdel: Delimiter):
        &#34;&#34;&#34;
            Recursive lists from string
        &#34;&#34;&#34;
        s = cls.escape(s)
        # surround it with double delimiters for correct space handling
        s = leftdel.unescaped_replace(s, &#34;(&#39;&#34;)
        s = rightdel.unescaped_replace(s, &#34;&#39;)&#34;)
        obj = cls(s)
        return obj.perform()

    @staticmethod
    def escape(s):
        return s.replace(&#39;(&#39;, r&#39;\(&#39;).replace(&#39;)&#39;, r&#39;\)&#39;)

    @staticmethod
    def unescape(s):
        return s.replace(r&#39;\(&#39;, &#39;(&#39;).replace(r&#39;\)&#39;, &#39;)&#39;)

    @classmethod
    def show_children(cls, tree):
        &#34;&#34;&#34;
            Pretty print commands and it&#39;s args
        &#34;&#34;&#34;
        name, children = tree
        if not children: return
        print(&#39;{} -&gt; {}&#39;.format(name,
                                &#39; &#39;.join(child[0] for child in children)))
        for child in children:
            cls.show_children(child)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="iahr.utils.Tokenizer.TOKS"><code class="name">var <span class="ident">TOKS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="iahr.utils.Tokenizer.escape"><code class="name flex">
<span>def <span class="ident">escape</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def escape(s):
    return s.replace(&#39;(&#39;, r&#39;\(&#39;).replace(&#39;)&#39;, r&#39;\)&#39;)</code></pre>
</details>
</dd>
<dt id="iahr.utils.Tokenizer.from_str"><code class="name flex">
<span>def <span class="ident">from_str</span></span>(<span>s, leftdel: <a title="iahr.utils.Delimiter" href="#iahr.utils.Delimiter">Delimiter</a>, rightdel: <a title="iahr.utils.Delimiter" href="#iahr.utils.Delimiter">Delimiter</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Recursive lists from string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_str(cls, s, leftdel: Delimiter, rightdel: Delimiter):
    &#34;&#34;&#34;
        Recursive lists from string
    &#34;&#34;&#34;
    s = cls.escape(s)
    # surround it with double delimiters for correct space handling
    s = leftdel.unescaped_replace(s, &#34;(&#39;&#34;)
    s = rightdel.unescaped_replace(s, &#34;&#39;)&#34;)
    obj = cls(s)
    return obj.perform()</code></pre>
</details>
</dd>
<dt id="iahr.utils.Tokenizer.parse_inner"><code class="name flex">
<span>def <span class="ident">parse_inner</span></span>(<span>toks)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse once we're inside an opening bracket.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse_inner(cls, toks):
    &#34;&#34;&#34;
        Parse once we&#39;re inside an opening bracket.
    &#34;&#34;&#34;
    ty, name = next(toks)
    children = []
    if ty != &#39;WORD&#39;:
        raise ParseError(IahrConfig.LOCAL[&#39;Brackets should start&#39;])

    while True:
        ty, s = next(toks)
        if ty == &#39;(&#39;:
            children.append(cls.parse_inner(toks))
        elif ty == &#39;)&#39;:
            return name, children</code></pre>
</details>
</dd>
<dt id="iahr.utils.Tokenizer.parse_root"><code class="name flex">
<span>def <span class="ident">parse_root</span></span>(<span>toks)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse this grammar:
ROOT ::= '(' INNER
INNER ::= WORD ROOT* ')'
WORD ::= [A-Za-z]+</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse_root(cls, toks):
    &#34;&#34;&#34;
        Parse this grammar:
        ROOT ::= &#39;(&#39; INNER
        INNER ::= WORD ROOT* &#39;)&#39;
        WORD ::= [A-Za-z]+
    &#34;&#34;&#34;
    ty, _ = next(toks)
    if ty != &#39;(&#39;:
        raise ParseError(IahrConfig.LOCAL[&#39;Surround tokens&#39;])
    return cls.parse_inner(toks)</code></pre>
</details>
</dd>
<dt id="iahr.utils.Tokenizer.show_children"><code class="name flex">
<span>def <span class="ident">show_children</span></span>(<span>tree)</span>
</code></dt>
<dd>
<div class="desc"><p>Pretty print commands and it's args</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def show_children(cls, tree):
    &#34;&#34;&#34;
        Pretty print commands and it&#39;s args
    &#34;&#34;&#34;
    name, children = tree
    if not children: return
    print(&#39;{} -&gt; {}&#39;.format(name,
                            &#39; &#39;.join(child[0] for child in children)))
    for child in children:
        cls.show_children(child)</code></pre>
</details>
</dd>
<dt id="iahr.utils.Tokenizer.unescape"><code class="name flex">
<span>def <span class="ident">unescape</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def unescape(s):
    return s.replace(r&#39;\(&#39;, &#39;(&#39;).replace(r&#39;\)&#39;, &#39;)&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="iahr.utils.Tokenizer.perform"><code class="name flex">
<span>def <span class="ident">perform</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Commodity function that glues it alltogether</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def perform(self):
    &#34;&#34;&#34;
        Commodity function that glues it alltogether 
    &#34;&#34;&#34;
    toks = self.tokenize()
    return self.parse_root(toks)</code></pre>
</details>
</dd>
<dt id="iahr.utils.Tokenizer.tokenize"><code class="name flex">
<span>def <span class="ident">tokenize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Tokenize a string.
Tokens yielded are of the form (type, string)
Possible values for 'type' are '(', ')' and 'WORD'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tokenize(self):
    &#34;&#34;&#34;
        Tokenize a string.
        Tokens yielded are of the form (type, string)
        Possible values for &#39;type&#39; are &#39;(&#39;, &#39;)&#39; and &#39;WORD&#39;
    &#34;&#34;&#34;
    s = self.s
    for match in self.TOKS.finditer(s):
        s = match.group(0)
        if s[0] == &#39; &#39;:
            continue
        if s[0] in &#39;()&#39;:
            yield s, s
        else:
            yield &#39;WORD&#39;, self.unescape(s[1:-1])</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="iahr" href="index.html">iahr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="iahr.utils.argstr" href="#iahr.utils.argstr">argstr</a></code></li>
<li><code><a title="iahr.utils.errstr" href="#iahr.utils.errstr">errstr</a></code></li>
<li><code><a title="iahr.utils.parenthesize" href="#iahr.utils.parenthesize">parenthesize</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="iahr.utils.AccessList" href="#iahr.utils.AccessList">AccessList</a></code></h4>
<ul class="two-column">
<li><code><a title="iahr.utils.AccessList.ALDecoder" href="#iahr.utils.AccessList.ALDecoder">ALDecoder</a></code></li>
<li><code><a title="iahr.utils.AccessList.ALEncoder" href="#iahr.utils.AccessList.ALEncoder">ALEncoder</a></code></li>
<li><code><a title="iahr.utils.AccessList.allow" href="#iahr.utils.AccessList.allow">allow</a></code></li>
<li><code><a title="iahr.utils.AccessList.ban" href="#iahr.utils.AccessList.ban">ban</a></code></li>
<li><code><a title="iahr.utils.AccessList.check_me" href="#iahr.utils.AccessList.check_me">check_me</a></code></li>
<li><code><a title="iahr.utils.AccessList.is_allowed" href="#iahr.utils.AccessList.is_allowed">is_allowed</a></code></li>
<li><code><a title="iahr.utils.AccessList.is_special" href="#iahr.utils.AccessList.is_special">is_special</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="iahr.utils.ActionData" href="#iahr.utils.ActionData">ActionData</a></code></h4>
<ul class="">
<li><code><a title="iahr.utils.ActionData.from_event" href="#iahr.utils.ActionData.from_event">from_event</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="iahr.utils.CommandDelimiter" href="#iahr.utils.CommandDelimiter">CommandDelimiter</a></code></h4>
<ul class="">
<li><code><a title="iahr.utils.CommandDelimiter.full_command" href="#iahr.utils.CommandDelimiter.full_command">full_command</a></code></li>
<li><code><a title="iahr.utils.CommandDelimiter.is_command" href="#iahr.utils.CommandDelimiter.is_command">is_command</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="iahr.utils.Delayed" href="#iahr.utils.Delayed">Delayed</a></code></h4>
<ul class="">
<li><code><a title="iahr.utils.Delayed.do" href="#iahr.utils.Delayed.do">do</a></code></li>
<li><code><a title="iahr.utils.Delayed.init" href="#iahr.utils.Delayed.init">init</a></code></li>
<li><code><a title="iahr.utils.Delayed.undelay" href="#iahr.utils.Delayed.undelay">undelay</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="iahr.utils.Delimiter" href="#iahr.utils.Delimiter">Delimiter</a></code></h4>
<ul class="two-column">
<li><code><a title="iahr.utils.Delimiter.RE_ESCAPINGS" href="#iahr.utils.Delimiter.RE_ESCAPINGS">RE_ESCAPINGS</a></code></li>
<li><code><a title="iahr.utils.Delimiter.escape" href="#iahr.utils.Delimiter.escape">escape</a></code></li>
<li><code><a title="iahr.utils.Delimiter.escaped_replace" href="#iahr.utils.Delimiter.escaped_replace">escaped_replace</a></code></li>
<li><code><a title="iahr.utils.Delimiter.in_re" href="#iahr.utils.Delimiter.in_re">in_re</a></code></li>
<li><code><a title="iahr.utils.Delimiter.unescape" href="#iahr.utils.Delimiter.unescape">unescape</a></code></li>
<li><code><a title="iahr.utils.Delimiter.unescaped_re" href="#iahr.utils.Delimiter.unescaped_re">unescaped_re</a></code></li>
<li><code><a title="iahr.utils.Delimiter.unescaped_replace" href="#iahr.utils.Delimiter.unescaped_replace">unescaped_replace</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="iahr.utils.ParseError" href="#iahr.utils.ParseError">ParseError</a></code></h4>
</li>
<li>
<h4><code><a title="iahr.utils.SingletonMeta" href="#iahr.utils.SingletonMeta">SingletonMeta</a></code></h4>
</li>
<li>
<h4><code><a title="iahr.utils.Tokenizer" href="#iahr.utils.Tokenizer">Tokenizer</a></code></h4>
<ul class="two-column">
<li><code><a title="iahr.utils.Tokenizer.TOKS" href="#iahr.utils.Tokenizer.TOKS">TOKS</a></code></li>
<li><code><a title="iahr.utils.Tokenizer.escape" href="#iahr.utils.Tokenizer.escape">escape</a></code></li>
<li><code><a title="iahr.utils.Tokenizer.from_str" href="#iahr.utils.Tokenizer.from_str">from_str</a></code></li>
<li><code><a title="iahr.utils.Tokenizer.parse_inner" href="#iahr.utils.Tokenizer.parse_inner">parse_inner</a></code></li>
<li><code><a title="iahr.utils.Tokenizer.parse_root" href="#iahr.utils.Tokenizer.parse_root">parse_root</a></code></li>
<li><code><a title="iahr.utils.Tokenizer.perform" href="#iahr.utils.Tokenizer.perform">perform</a></code></li>
<li><code><a title="iahr.utils.Tokenizer.show_children" href="#iahr.utils.Tokenizer.show_children">show_children</a></code></li>
<li><code><a title="iahr.utils.Tokenizer.tokenize" href="#iahr.utils.Tokenizer.tokenize">tokenize</a></code></li>
<li><code><a title="iahr.utils.Tokenizer.unescape" href="#iahr.utils.Tokenizer.unescape">unescape</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>